题目描述：
输入两个链表，找出它们的第一个公共结点。

思路：
看到这个题，立马就想到之前见过的快慢指针。不过仔细想想，好像快慢指针的应用里面没有这个，人家只是找环的

暴力的做法应该是固定一个链，循环另一个链，直到两个链的next相同。这样的复杂度应该是O(n^2)

另外还有一个想法是，因为这两个链表的尾部是相同的，所以从尾部出发。
递归到两个链表的尾部，然后往出退，退到两个链表结点不相同的时候。
问题是，如何让两个链表同时到达尾部呢，还能同时开始往出退呢？

做出来啦~~24ms
美滋滋

上面那个思路是不对的，因为没办法保证递归之后是从后面同步开始的。
现在的做法是，先分别遍历两个链表，数一下长度，两个链表后面部分是重合的，
所以只要让长的那个先多走一步，然后就两个链表指针同步移动就ok了。

哇哦🤩
/*
找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走
（因为2个链表用公共的尾部）
*/
这个评论区的解答跟我的思路一样嘿。


还有一种更巧妙的做法：（写到代码里啦）
长度相同有公共结点，第一次就遍历到；没有公共结点，走到尾部NULL相遇，返回NULL
长度不同有公共结点，第一遍差值就出来了，第二遍一起到公共结点；没有公共，一起到结尾NULL。