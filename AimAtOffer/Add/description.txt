题目描述
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

思路：
位运算实现加法

python没有无符号左/右移运算，需要越界检查

要考虑存在负数的情况，负数

首先补充知识，二进制算法是用补码计算的！补码！补码！重要的事情三遍！
首先正数举例，5+6：
bin(5)=0101,bin(6)=0110
首先我们在计算十进制的时候思路是这样的，5+6=11，首先看1，之后发现需要左移也就是所谓的进1，变成11，二进制是类似的;
第一次，0101^0110=0011
                0101&0111=0100，发现0100！=0000，所以是需要进位左移  0100<<1=1000
第二次, 0011^1000=1011
                0011&1000=0000，发现0000==0000，所以返回1011，也就是11
之后负数举例，5-6：(以8位举例)
bin(5)=00000101,bin(-6)=10000110,反码:11111001,补码:11111010
开始计算：
第一次，00000101^11111010=11111111
                00000101&11111010=00000000==00000000，注意11111111是补码，需要转换回去,反码11111110，源码10000001=-1，num1-pow(2,32)作用就是类似,255-256=-1

我要好好捋一下，结合之前 二进制中1的个数那个题目。
首先，python在二进制表示这里是与其他编程语言有不一样的地方的。
python中求负数的补码是  a & 0xffffffff

像上面那个举例，5-6，最后得到的 11111111是一个补码，一个负数的补码形式，要把它转换成数字表示，但是python会把它认为是正数。那怎么求呢？
以4位为例，-2的 原码-反码-补码 是 1010 - 1101 - 1110
那给出-2的补码1110，在python不认为前面的1是符号位的情况下，要求-2。python认为这个二进制表示是14，所以是14-16=-2的补码1110，在python不认为前面的1是符号位的情况下，要求也就是 补码-pow(2, 32) -> ~(补码 ^ 0xffffffff)

python中，正数 & 0xffffffff 是没有任何变化的，但是  负数 & 0xffffffff 之后就会变成它的补码

# 测试示例
>>> bin(-2 & 0xf)
'0b1110'
>>> -2 & 0xf
14
>>> 


# TODO
整理的时候，可以和  二进制中1的个数  好好捋捋。