题目描述：
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入描述：
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

思路：
我的做法：
很粗暴。运行时间是34ms
正常排列组合思路的实现，先从字符串中任意取出一个字符，添加到一个存储字符串变量中，然后将去掉这个字符的字符串不断递归，直到字符串为空，就把当前存储字符串的变量添加到self.arr中
由于可能会出现重复情况，所以在添加前要判断一下这个字符串是不是已经在self.arr中了（这里就很暴力...）
最后由于要按照字典序输出，就用了一下python的排序函数sorted()（粗暴again）


全排列的字典序法：
一般而言，设P是[1,n]的一个全排列。
P=P1P2…Pn=P1P2…Pj-1PjPj+1…Pk-1PkPk+1…Pn
　　find:　　j=max{i|Pi<Pi+1}
　　　　　　　k=max{i|Pi>Pj}
　　　1，  对换Pj，Pk，
　　　2，  将Pj+1…Pk-1PjPk+1…Pn翻转
P’= P1P2…Pj-1PkPn…Pk+1PjPk-1…Pj+1即P的下一个

26ms
就按照上述描述实现
先把输入的字符串递增排序
不断地去找当前排序的下一个排序（就是按字典序来说的下一个）
步骤：
1. 先从后往前，找到第一个减小的位置X，比如 4653，X为6（46653这样的情况，找到的是第一个6）
2. 从X开始往后找，找到最后一个大于X-1位置的位置Y，Y为5
3. 交换Y和X-1，变成5643
4. 把X之后的所有逆序，变成5346
5. 循环结束条件为整个序列都是递减的，即X位置为第一个时